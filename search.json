[{"title":"javase复习","url":"/2019/12/19/javase复习/","content":"## 第一部分（java入门）\n#### java特点\njava是目前使用最为广泛的网络编程语言之一，它具有语法<strong>简单，面向对象，稳定，与平台无关，多线程，动态</strong>等特点，而平台无关是java最初风靡世界的最重要的原因。\n#### JVM\nJVM本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。\n#### JDK\njava语言的软件开发工具包，包含了java的运行环境和java工具。\n#### Java的编译与运行\nJava的编译：进入到当前目录下，使用javac命令将java文件编译成class文件。\n![](/img/java/Java的编译.jpg)\nJava的运行：java文件编译后，再使用java命令将其运行。\n![](/img/java/java的运行.jpg)\n#### Java main函数\n写法：\n```\npublic static void main(String [] args){\n\n}\n```\n特殊之处：其格式是固定的，会被JVM识别和调用。\n\n---\n\n## 第二部分（基本数据类型和数组）\n#### 标识符规则\n+ 标识符由字母、下划线、美元符号和数字组成，长度不受限制。\n+ 标识符第一个字符不能是数字字符。\n+ 标识符不能是关键字。\n+ 标识符不能是true、false和null（尽管true、flase、null不是关键字）。\n+ 标识符中的字母是区分大小写的，hello和Hello是不同的标识符。\n#### 字符集\njava使用Unicode字符集，该字符集由UNICODE协会更改，最多可以识别65536个字符。\n#### 关键字\n关键字就是有特定用途或被赋予特定特定意义的一些单词，不可以把关键字当做标识符。\n#### 基本数据类型\n逻辑类型：boolean\n整数类型：byte、short、int、long\n字符类型：char\n浮点类型：float、double\n#### 类型转换\n当把一种基本数据类型变量的值赋给另一种基本类型变量时，就涉及数据转换。有以下类型会涉及数据转换，将其按照精度由低到高排列：\nbyte short char int long float double\n当把级别低的变量的值赋予级别低的变量时，系统会自动完成类型转换。例如：\n```\nint x = 50;\nfloat y;\ny = x; //y值输出为50.0\nfloat z = 100; //z值输出为100.0\n```\n如果级别高的变量赋给级别低的变量时，必须使用类型转换运算，其格式为：\n(类型名)要转换的值\n例如：\n```\nint x = (int)34.89; //x输出为34\nlong y = (long)56.89F; //y输出为56\nint z = (int)1999L; //z输出为1999\n```\n#### 输入基本型数据\nScanner是JDK1.5新增的一个类，可以用该类来创建一个对象，例如：\n```\nScanner scanner = new Scanner(System.in);\n```\n然后scanner对象可调用相关方法来输入各种基本数据类型，例如：\n```\nx = scanner.nextBoolean(); //输入一个boolean型数据\nx = scanner.nextByte(); //输入一个byte型数据\nx = scanner.nextShort(); //输入一个short型数据\nx = scanner.nextInt(); //输入一个int型数据\nx = scanner.nextLong(); //输入一个long型数据\nx = scanner.nextFloat(); //输入一个float型数据\nx = scanner.nextDouble(); //输入一个double型数据\n```\n#### 输出基本型数据\nSystem.out.print()和System.out.println()都可输出数据，区别在于前者输出不换行，后者输出要换行。允许使用并置符号+将变量、表达式或一个常量值与一个字符串并置一起输出，如：\n```\nSystem.out.print(m+\"个数的和为\"+n);\nSystem.out.println(123+\"大于\"+122);\n```\n输出字符串时，若字符串较长，可将字符串分解为几部分，但是不可以出现回车，例如：\n正确输出：\n```\nSystem.out.println(\"hello \"+\n          \"world\");\n```\n错误输出：\n```\nSystem.out.println(\"hello\n          world\");\n```\n另外，JDK1.5中还增加了和C语言中一样的输出方法，例如：\n```\nSystem.out.printf(\"%d,%f\",12,12.0);\n```\n#### 数组\n申明方法：\n```\nfloat a[]; //一维数组\nfloat b[][]; //二维数组\nint [] a,b[]; //申明一个一维数组a和二维数组b，等价于int a[],b[][];\n```\n分配元素;\n```\na = new float[4];\n```\n申明+分配：\n```\nint a[] = new int[4];\nint b[][] = new int[3][4];\n```\nlength的使用\n对于一维数组，“数组名.length”的值就是数组的长度，对于二维数组而言，“数组名.length”的值是二维数组里面一维数组的个数，例如：\n```\nint a[] = new int[10]; //a.length = 12\nint b[][] = new int [3][4]; //b.length = 3\n```\n数组初始化\n创建数组后，系统会给数组每个元素一个初始值，例如int型是0。在申明数组同时可以给数组的元素一些初始值，例如：\n```\nint a[] = {1,2,3,4};\n```\n相当于：\n```\nint a[] = new int[4];\na[0] = 1;\na[1] = 2;\na[2] = 3;\na[3] = 4;\n```\n---\n\n## 第三部分（运算符与表达式）\n#### 运算符\n自增自减运算：\n++x(--x)在使用x之前，先将x的值进行增（减）1；\nx++(x--)在使用x之后，使x得值进行增（减）1；\n关系运算\n运算符   | 用法     | 含义\n:------: | :------: |:-------:\n>        | a>b      | a大于b\n<        | a<b      | a小于b\n>=       | a>=b     | a大于等于b\n<=       | a<=b     | a小于等于b\n==       | a==b     | a等于b\n!=       | a!=b     | a不等于b\n\n#### 语句概括\nif语句：\n```\nif(表达式){\n   若干语句\n}\n```\nif-else语句：\n```\nif(表达式){\n  若干语句\n}\nelse(表达式){\n  若干语句\n}\n```\nswitch开关语句：\n```\nswitch(表达式){\n  case 常量值1:\n           若干语句\n           break;\n  case 常量值2：\n           若干语句\n           break;\n  ···\n  case 常量值3：\n           若干语句\n           break;\n  default:\n       若干语句\n}\n```\nfor循环语句：\n```\nfor(表达式1;表达式2;表达式3){\n  若干语句\n}\n```\nwhile循环语句：\n```\nwhile(表达式){\n  若干语句\n}\n```\ndo-while循环语句：\n```\ndo{\n  若干语句\n}while(表达式)\n```\nfor-each循环语句：\n```\nfor(声明循环变量:数组名字){\n  ···\n}\n```\n---\n\n## 第四部分（类和对象）\n#### 类\nclass关键字：\n用来定义类，“class 类名”是类的声明部分，类名必须是合法的标识符。两个大括号及其之间的内容是类体。\n构造方法：\n构造方法是类中的一种特殊方法，当程序用类创造对象时需使用它的构造方法。类中的构造方法的名字必须和他所在的类的名字完全相同，而且没有类型。允许一个类中编写若干个构造方法，但必须保证他们参数不同。参数不同是指：参数的个数不同，或者参数的个数相同，但参数列表中对应的某个参数的类型不同。如果类中没有编写构造方法，系统会默认该类只有一个构造方法，该默认的构造方法是无参的，且方法中没有语句。\n\n重写(Override)：\n+ 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！\n+ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n+ 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n\n重载(Overload)：\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n最常用的地方就是构造器的重载。\n\npackage：\n+ 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n+ 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n+ 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n+ Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n#### 继承：\n+ 子类拥有父类非 private 的属性、方法。\n+ 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n+ 子类可以用自己的方式实现父类的方法。\n+ Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n+ 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\nextends关键字：\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\nimplements关键字：\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\n\nsuper关键字：\n可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：\n指向自己的引用。\n\nfinal关键字：\nfinal关键字声明的类不能继承，即最终类；或用于修饰方法，不能被子类重写。\n\nstatic关键字：\nstatic方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。\n\n#### 多态\n定义：\n是指同一个行为有不同表现形式或形态的能力。\n\n多态优点：\n+ 消除类型之间的耦合关系\n+ 可替换性\n+ 可拓展性\n+ 接口性\n+ 灵活性\n+ 简化性\n\n多态存在条件：\n+ 继承\n+ 重写\n+ 父类引用指向子类对象\n\nabstract关键字：\n用来定义抽象类，抽象方法。\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。且由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。\n声明抽象方法会造成以下两个结果：\n+ 任何一个类包含抽象方法，那么这个类一定得是抽象类。\n+ 任何子类必须重写父类抽象方法，或者声明自身就是抽象类\n\n接口：\n+ 在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n+ 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n+ 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n+ 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n---\n\n## 第五部分（异常）\n异常类层次：\n+ 所有的异常类是从 java.lang.Exception 类继承的子类。\n\n+ Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\n+ Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\n+ Error 用来指示运行时环境发生的错误。\n\n+ 异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n通用异常：\n+ JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n+ 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。\n\n捕获异常：\n使用try-catch关键字可以捕获异常，try/catch放在异常可能发生的地方，语法如下：\n```\ntry(){\n\n}catch(Exception e){\n  e.printStackTrace();\n}\n```\nfinally关键字：\nfinally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下：\n```\ntry{\n  //程序代码\n}catch(异常1 异常的变量名1){\n  //程序代码\n}catch(异常2 异常的变量名2){\n  //程序代码\n}finally{\n  //程序代码\n}\n```\n\n---\n\n## 第六部分（常用实用类）\n#### String类\n用途：用来创建和操作字符串，由于java把String类定义为final类，所以String类不可拓展，也不能有子类。\n常用方法：\nlength()\n用途：获取长度，例如：\n```\nString a = \"bird\";\nint b = a.length(); //b的值为4\n```\nequals(String s)\n用途：比较当前String对象的字符串序列参数s指定的String对象的字符串序列相同，例如：\n```\nString s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\nSystem.out.println(s1.equals(s2)); //True\nSystem.out.println(s1 == s2); //False\nString s3 = \"hi\";\nString s4 = \"hi\";\nSystem.out.println(s3.equals(s4)); //True\nSystem.out.println(s3 == s4); //True\n```\nstartsWith(String s)\n用途：判断当前String对象的字符串前缀是否是参数指定的String对象s的字符串序列，例如：\n```\nString s1 = \"hello\";\ns1.startsWith(\"he\"); //True\ns1.startsWith(\"hi\"); //False\n```\nendsWith(String s)\n用途：判断当前String对象的字符串后缀是否是与参数指定的String对象s的字符串序列，用法与startsWith(String s)相同。\n\ncontains(String s)\n用途：判断当前String对象是否含有参数指定的String对象s的字符串序列，用法与equals(String s)相同。\n\nindexOf(String s)\n用途：查找字符的索引，indexOf(String s,int a)方法是重载方法，参数a的值用来指定检索的开始位置，例如：\n```\nString tom = \"I am a good cat\";\ntom.indexOf(\"a\"); // 值为2\ntom.indexOf(\"good\",2); //值为7\ntom.indexOf(\"a\",7); //值为13\ntom.indexOf(\"w\",2); //值为-1\n```\n#### StringBuffer类\nStringBuffer类与String类不同，StringBuffer类的对象的实体的内存空间可以自由的改变大小，便于储存一个可变的字符序列。\n常用方法：\nappend(String s)\n用途：将指定字符串添加到此字符串序列\nreverse(String s)\n用途：翻转字符串\ndelete(int start,int end)\n用途：从此字符串中删除指定字符串\nreplace(int start,int end,String s)\n用途：用指定字符串替换指定字符串\ninsert(int offect,int i)\n用途：将int参数的字符串插入到此序列中\ncapacity()\n用途：返回当前字符串容量\n\n#### Date()类\n使用无参构造方法可获得当前时间和日期，使用带参构造方法获得“公元”前后时间，其公元设置为1970年1月1日0时\n\n#### Calendar类\n使用Calendar类的static方法getInstance()可初始化一个日历对象，且Calendar对象调用方法可将日历翻到任何一个时间。\n其可调用方法为：\n```\npublic final void set(int year,int month,int date);\npublic final void set(int year,int month,int date,int hour,int minute);\npublic final void set(int year,int month,int date,int hour,int minute,int second);\n```\n\n#### Math类\n常用方法：\nlong abs(double a)\n用途：返回a的绝对值\ndouble max(double a,double b)\n用途：返回a、b的最大值\ndouble min(double a,double b)\n用途：返回a、b的最小值\ndouble random()\n用途：产生一个0~1的随机数\ndouble pow(double a,double b)\n用途：返回a的b次幂\ndouble sqrt(double a)\n用途：返回a的平方根\ndouble log(double a)\n用途：返回a的对数\ndouble ceil(double a)\n用途：返回大于a的最小整数，并将其转化为double类型\ndouble floor(double a)\n用途：返回小于a的最大整数，并将整数转化为double型\nlong round(double a)\n用途：四舍五入\n\n---\n\n## 第七部分（泛型）\n泛型是在JDK1.5中推出的，其主要目的是建立具有类型安全的集合框架，如链表，散列映射等数据结构。\n\n#### LinkedList<E>泛型类\nLinkedList<E>是实现了泛型接口List<E>的泛型类，而泛型接口List<E>又是collection<E>泛型接口的子接口。LinkedList<E>泛型类中绝大部分方法都是泛型接口的实现。\nLinkedList<E>的常用方法：\nadd(E element)\n用途：向链表末尾添加新节点，该节点数据是参数element指定的数据\nadd(int index,E element)\n用途：向链表指定位置添加新节点，其数据是element指定的数据\nclear()\n用途：清空链表\nremove(E element)\n用途：删除首次出现含有element数据的节点\nget(int index)\n用途：得到链表中指定位置处的节点\nindexOf(E element)\n用途：返回含有数据element节点首次出现的位置\nlastIndexOf(E element)\n用途：返回含有数据element节点数据最后出现位置，如果没有，返回-1\nset(int index,E element)\n用途：将当前链表index处的数据替换为element\nsize()\n用途：返回长度\ncontains(Object element)\n用途：判断是否含有element\n\n用iterator遍历linkedList<E>\n```\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class iteratorLink {\n    public static void main(String[] args) {\n        Link<String> list = new 遍历linkedList<>();\n        for(int i = 0;i<10;i++){\n          list.add(\"我是第\"+i+\"个元素\");\n        }\n        //使用iterator进行遍历\n        Iterator<String> iterator = list.iterator();\n        while(iterator.hasNext()){\n          String a = iterator.next();\n          System.out.println(a);\n        }\n    }\n}\n```\n利用sort方法给链表升序排序：\n```\nimport java.util.*;\n\npublic class iteratorLink {\n    public static void main(String[] args) {\n        List<String> list = new LinkedList<>();\n        for (int i = 0; i <10 ; i++) {\n            double a = Math.random()*10;\n            int b = (int) Math.round(a);\n            list.add(\"我是第\"+b+\"个元素\");\n        }\n        Iterator<String> iterator = list.iterator();\n        System.out.println(\"排序前数据：\");\n        while (iterator.hasNext()){\n            String s = iterator.next();\n            System.out.println(s);\n        }\n        //引入sort方法\n        Collections.sort(list);\n        System.out.println(\"排序后数据：\");\n        iterator = list.iterator();\n        while (iterator.hasNext()){\n            String s = iterator.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n#### HashMap<k,V>泛型类\nHashMap<k,v>泛型类实现了泛型接口Map<k,v>,HasnMap<k,v>类中绝大部分方法都是Map<k,v>方法的实现\n常用方法\nclear()\n用途：清空散列映射。\nclone()\n用途：返回当前映射的一个克隆。\ncontainsKey(Object key)\n用途：如果散列映射有键/值对使用了参数指定的键，返回true，否则返回false。\ncontainsValue(Object value)\n用途：与containsKey相同\nget(Object key)\n用途：返回映射中使用key做键的键/值中对的值。\nisEmpty()\n用途：为空返回true,不为空返回false。\nremove(Object key)\n用途：删除相对应的值，并返回删除的值。\nsize()\n用途：返回映射大小，即键/值对数目。\n\n#### TreeSet<E>泛型\nTreeSet<E>类是实现Set<E>接口的类，它的大部分方法都在接口方法实现。TreeSet<E>类所创建的对象称作数集。数集采用树结构存储数据，树结点中的数据会按存放的数据的“大小”顺序一层一层依次排序，在同一层中结点从左到右按字典序从大到小依次递增排列，下一层比上一层小。\n\n常用方法：\nadd(E o)\n用途：向树集中添加结点，节点中的数据由参数指定，添加成功返回true，否则false。\nclear()\n用途：删除树集中所有结点。\ncontains(Object o)\n用途：如果树集中包含参数指定对象，返回true，否则false。\nfirst()\n用途：返回第一个结点的数据（最小的结点）。\nlast()\n用途：返回最后一个结点的数据（最大的结点）。\nisEmpty()\n用途：判断是否为空树集，若空则返回true，不空则返回false。\nremove(Object o)\n用途：删除存储参数指定的对象的最小结点，若成功，返回true，否则false。\nsize()\n用途：返回结点数目。\n\n---\n\n## 第八部分（多线程）\n#### 线程与进程\n线程不是进程，但线程的行为很像进程，线程是比进程更小的执行单位，一个进程在其执行过程中，可以产生多个线程，形成多条执行线索，每条线索，即每个线程也有他自身的产生、存在和消亡的过程。和进程共享操作系统资源类似，线程间也可以共享进程中的某些内存单元（包括代码和数据），并利用这些共享单元来实现数据交换、实时通信和必要的同步操作，但与进程不同的是，线程的中断和恢复可以更加节省系统的开销。具有多个线程的进程能更好地表达和解决现实世界中的具体问题，多线程是计算机应用开发和程序设计的一项重要的使用技术。\n没有进程就不会有线程，就像没有操作系统就没有进程一样。尽管线程不是进程，许多方面线程非常类似线程，通俗的讲，线程就是进程中的“小进程”。\n\n#### 线程的状态\n新建：当一个Thread类或者其子类对象被声明或者创建时，新生的线程对象处于新建状态。此时它已经具有了相应的内存空间和其他资源。\n\n运行：线程创建之后就具备了运行的条件，一旦轮到它来享用CPU资源时，即JVM将CPU使用权换给该线程后，此线程就可以脱离它的主线程来开始自己的生命周期。\n\n中断：\n+ 即JVM将CPU资源从当前线程切换到其他线程，使本线程让出CPU使用权处于中断状态。\n+ 执行了sleep()方法，就让出了CPU的使用权。\n+ 执行了wait()方法，使得线程进入等待状态。\n+ 执行io操作进入阻塞状态。\n\n死亡：处于死亡的线程不在具有继续运行的能力。死亡原因有二：执行完run()方法，强制执行完run()方法。\n\njava多线程状态转换图\n\n![](/img/java/多线程状态.jpg)\n\n#### 线程的创建\n继承Thread类：\n```\npublic class threadTest {\n    public static void main(String[] args) {\n        Thread a = new thread1();\n        a.start();\n    }\n}\n\nclass thread1 extends Thread{\n    public void run(){\n        try {\n            int i = 5;\n            while (i>=0){\n                System.out.println(\"my name is Thead1\");\n                setPriority(i);\n                System.out.println(\"我的优先级为：\"+Thread.currentThread().getPriority());\n                i--;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n实现runnable接口：\n```\npublic class runnTest {\n    public static void main(String[] args) {\n        ttst ttst = new ttst();\n        Thread t1 = new Thread(ttst);\n        t1.setName(\"窗口1\");\n        Thread t2 = new Thread(ttst);\n        t2.setName(\"窗口2\");\n        t1.start();\n        t2.start();\n    }\n}\n\nclass ttst implements Runnable{\n    private static int ticket = 100;\n    public void run(){\n        while (ticket>0){\n            try {\n                System.out.println(Thread.currentThread().getName()+\"有票，票号为：\"+ticket);\n                ticket--;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### 线程安全问题\n+ 线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。\n+ 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。\n\nsynchronized关键字：\n在Java中，任何类的对象都可以充当java的锁，例如：\n```\npublic class runnTest {\n    public static void main(String[] args) {\n        ttst ttst = new ttst();\n        Thread t1 = new Thread(ttst);\n        t1.setName(\"窗口1\");\n        Thread t2 = new Thread(ttst);\n        t2.setName(\"窗口2\");\n        t1.setPriority(5);\n        t2.setPriority(5);\n        t1.start();\n        t2.start();\n    }\n}\n\nclass ttst implements Runnable{\n    private static int ticket = 100;\n    //用dog类的对象来充当锁\n    dog a = new dog();\n    public void run(){\n        while (ticket>0){\n            synchronized (a){\n                try {\n                    System.out.println(Thread.currentThread().getName()+\"有票，票号为：\"+ticket);\n                    ticket--;\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n}\n//创建一个dog类\nclass dog{\n\n}\n```\n在实现runnable接口的线程中，也可以使用this\n```\npublic class runnTest {\n    public static void main(String[] args) {\n        ttst ttst = new ttst();\n        Thread t1 = new Thread(ttst);\n        t1.setName(\"窗口1\");\n        Thread t2 = new Thread(ttst);\n        t2.setName(\"窗口2\");\n        t1.setPriority(5);\n        t2.setPriority(5);\n        t1.start();\n        t2.start();\n    }\n}\n\nclass ttst implements Runnable{\n    private static int ticket = 100;\n    public void run(){\n        while (ticket>0){\n            synchronized (this){ //此时this指的是ttst对象\n                try {\n                    System.out.println(Thread.currentThread().getName()+\"有票，票号为：\"+ticket);\n                    ticket--;\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n}\n\n```\n在继承Thread的线程中使用类.class\n```\npublic class TheradTes {\n    public static void main(String[] args) {\n        window win1 = new window();\n        window win2 = new window();\n        win1.setName(\"窗口1\");\n        win2.setName(\"窗口2\");\n        win1.start();\n        win2.start();\n    }\n}\n\n\nclass window extends Thread{\n    private static int ticket = 100;\n    public void run(){\n        while (ticket>0){\n            synchronized (window.class){ //此时window.class指一个window对象\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName()+\"有票，票号为\"+ticket);\n                ticket--;\n            }\n\n        }\n    }\n}\n```\n\n---\n\n## 第九部分（java与mysql）\n#### Driver的作用\n为java提供访问数据库的能力\n\n#### java操作数据库\n准备工作：\n```\nprivate static String url = \"jdbc:mysql://localhost:3306/test\";\nprivate static String user = \"root\";\nprivate static String password = \"123456\";\n```\n插入数据：\n```\npublic void add(int a,String b)  {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(url,user,password);\n            String sql = \"insert into login(user,password) values (?,?)\";\n            PreparedStatement ps = conn.prepareStatement(sql);\n            ps.setInt(1,a);\n            ps.setString(2,b);\n            ps.execute();\n            ps.close();\n            conn.close();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n```\n修改数据：\n```\npublic void upDate(String a,int b) {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(url,user,password);\n            String sql = \"update login set password = ? where user = ?\";\n            PreparedStatement ps = conn.prepareStatement(sql);\n            ps.setString(1,a);\n            ps.setInt(2,b);\n            ps.execute();\n            ps.close();\n            conn.close();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n```\n删除数据：\n```\npublic void delete() {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(url,user,password);\n            String sql = \"delete from login where user = ?\";\n            PreparedStatement ps = conn.prepareStatement(sql);\n            ps.setInt(1,1);\n            ps.execute();\n            ps.close();\n            conn.close();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n```\n查询数据：\n```\npublic void select() {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(url,user,password);\n            String sql = \"select user,password from login where user = ?\";\n            PreparedStatement ps = conn.prepareStatement(sql);\n            ps.setInt(1,2);\n            ResultSet resultSet = ps.executeQuery();\n            if (resultSet.next()){\n                int id = resultSet.getInt(1);\n                String password = resultSet.getString(2);\n                System.out.println(\"账号：\"+id+\",密码：\"+password);\n            }\n            ps.close();\n            conn.close();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## 第十部分（io流）\n#### 流的概念和作用\n流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。\n\n#### 流的分类\n\n输入流：\n+ InputStream 是所有的输入字节流的父类，它是一个抽象类。\n+ ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。\n+ PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。\n+ ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。\n\n输出流：\n+ OutputStream 是所有的输出字节流的父类，它是一个抽象类。\n+ ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。\n+ PipedOutputStream 是向与其它线程共用的管道中写入数据。\n+ ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。\n\n读写流：\n```\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"源文件\"));\n         BufferedWriter writer = new BufferedWriter(new FileWriter(\"目标文件\"))) {\n        String line = null;\n        // 利用BufferedReader/BufferedWriter逐行读取文件内容，提升I/O性能\n        while ((line = reader.readLine()) != null) {\n            writer.write(line);\n            writer.newLine();\n        }\n        writer.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n节点流和过滤器流：\n节点流：从特定地方读写的流类。\n过滤器流：使用节点流作为输入或输出。过滤流是使用一个已经存在的输入流或者输出流链接创建的。过滤流的主要特点是在输入输出数据的同时能对所传输的数据做指定类型或格式的转换，即可实现对二进制字节数据的理解和编码转换。\n\n#### java中的目录\n创建目录：\n+ kdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\n+ mkdirs()方法创建一个文件夹和它的所有父文件夹。如：\n```\nString dirname = \"/tmp/user/java/bin\";\n        File d = new File(dirname);\n        // 现在创建目录\n        d.mkdirs();\n```\n\n读取目录：\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。\n如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。\n可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。\n```\nString dirname = \"/tmp\";\n        File f1 = new File(dirname);\n        if (f1.isDirectory()) {\n            System.out.println(\"目录 \" + dirname);\n            String s[] = f1.list();\n            for (int i = 0; i < s.length; i++) {\n                File f = new File(dirname + \"/\" + s[i]);\n                if (f.isDirectory()) {\n                    System.out.println(s[i] + \" 是一个目录\");\n                } else {\n                    System.out.println(s[i] + \" 是一个文件\");\n                }\n            }\n        } else {\n            System.out.println(dirname + \" 不是一个目录\");\n        }\n    }\n```\n删除目录：\n删除文件可以使用 java.io.File.delete() 方法。需要注意当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。如：\n```\npublic static void main(String args[]) {\n        // 这里修改为自己的测试目录\n        File folder = new File(\"/tmp/java/\");\n        deleteFolder(folder);\n    }\n\n    // 删除文件及目录\n    public static void deleteFolder(File folder) {\n        File[] files = folder.listFiles();\n        if (files != null) {\n            for (File f : files) {\n                if (f.isDirectory()) {\n                    deleteFolder(f);\n                } else {\n                    f.delete();\n                }\n            }\n        }\n        folder.delete();\n    }\n```\n\n---\n\n\n\n## 参考资料\n\n参考教程：《java2实用教程第五版》\n参考文档：[菜鸟教程/java教程](https://www.runoob.com/java/java-tutorial.html)\n参考博客：[Java IO深入理解](https://blog.csdn.net/yhl_jxy/article/details/79272792)\n参考博客：[Java IO流学习总结](https://blog.csdn.net/zhaoyanjun6/article/details/54292148)\n参考博客：[Java I/O操作](https://www.jianshu.com/p/21ed71b26a5d)\n参考博客：[Java Reader/Writer](https://blog.csdn.net/u014316026/article/details/80637695)\n参考视频[java基础到高级](https://search.bilibili.com/all?keyword=av48370019)\n参考视频[jdbc核心技术](https://search.bilibili.com/all?keyword=av67955358)","tags":["java"]},{"title":"es6那些事(2)箭头函数","url":"/2019/09/23/es6那些事-2-箭头函数/","content":"## 我叫箭头函数\n---\n### 箭头函数的特点\n\n#### (1)语法简洁\njs的函数的一般写法\n```\nconst numbers = [5,6,13,0,1,18,23];\n        const double = numbers.map(function(number){\n            return number*2;\n        });\n```\n 输出\n\n![](/img/一般函数.png)\n\n 箭头函数写法\n```\nconst numbers = [5,6,13,0,1,18,23];\n        const double = numbers.map((number) =>{\n            return number*2;\n        });\n```\n输出\n\n![](/img/箭头函数写法.png)\n\n一个参数可省掉括号\n```\nconst numbers = [5,6,13,0,1,18,23];\nconst double = numbers.map(number => {\n        return number*2;\n      });\n```\n输出\n\n![](/img/一个参数.png)\n\n没有参数不能省\n```\nconst numbers = [5,6,13,0,1,18,23];\nconst double = numbers.map(() => {\n               return 'hello';\n       }); \n```\n输出\n\n![](/img/没有参数.png)\n\n多参数写法\n```\nconst numbers = [5,6,13,0,1,18,23];\nconst double = numbers.map((number,i) =>{\n    return`${i}:${number*2}`\n      });\n```\n\n输出\n\n![](/img/多参数.png)\n\n##### 语法总结\n删掉function关键字，加上一个箭头(=>),多个参数用逗号分隔，且必须加括号，一个参数可不加，没有参数不能省。\n\n---\n\n#### (2)可以隐式返回\n先来看下显式返回\n```\nconst numbers = [5,6,13,0,1,18,23];\n        const double = numbers.map(function(number){\n            return number*2;\n        }); \n```\n输出\n\n![](/img/显式返回.png)\n显式返回必须要有大括号和return。\n\n隐式返回\n``` \nconst numbers = [5,6,13,0,1,18,23];\n        const double = numbers.map((number) => number*2); \n```\n输出\n\n![](/img/隐式返回.png)\n箭头函数的隐式返回则可以省掉大括号和return，语法更简洁。\n\n---\n\n#### (3)都是匿名函数\n命名函数写法\n```\nfunction greet(name){\n    console.log(`I am ${name}`);\n} \ngreet('bai');\n```\n输出\n\n![](/img/命名函数.png)\n\n箭头函数写法\n```\nconst greet = name =>{console.log(`I am ${name}`)}\ngreet('bai');\n```\n输出\n\n![](/img/匿名函数.png)\n\n---\n\n#### (4)箭头函数没有自己的this指向\n一般js函数\n```\nconst jelly={\n            name:'jelly',\n            hobbies:['codeing','slepping','reading'],\n            printHobbies:function(){\n                this.hobbies.map(function(hobby){\n                    console.log(`${this.name} love ${hobby}`);\n                })\n            }\n        }\n        jelly.printHobbies();\n```\n输出\n\n![](/img/普通this.png)\n由输出结果可知，name没有输出，可能是this指向问题，于是我们打印this\n```\n const jelly={\n            name:'jelly',\n            hobbies:['codeing','slepping','reading'],\n            printHobbies:function(){\n                this.hobbies.map(function(hobby){\n                               console.log(this);\n                    console.log(`${this.name} love ${hobby}`);\n                })\n            }\n        }\n        jelly.printHobbies();\n```\n输出\n\n![](/img/打印this.png)\n在js中，this指向是运行时才开始，而独立函数其指向默认指向window。\n为了解决此问题，我们通常申明一个变量赋值给this\n``` \nconst jelly={\n            name:'jelly',\n            hobbies:['codeing','slepping','reading'],\n            printHobbies:function(){\n                let self = this;\n                this.hobbies.map(function(hobby){\n                    console.log(`${self.name} love ${hobby}`);\n                })\n            }\n        }\n        jelly.printHobbies();\n```\n输出\n\n![](/img/赋值this.png)\n\n箭头函数写法\n ``` \n const jelly={\n            name:'jelly',\n            hobbies:['codeing','slepping','reading'],\n            printHobbies:function(){\n                this.hobbies.map(hobby =>{\n                    //console.log(this);\n                    console.log(`${this.name} love ${hobby}`);\n                })\n            }\n        }\n        jelly.printHobbies();\n ```\n 输出\n\n ![](/img/箭头函数this.png)\n 完美输出，原因是因为箭头函数没有自己this指向，其this指向继承其父函数，如果其父函数也是箭头函数的话，那就再往上继承。\n\n ---\n\n ### 使用箭头函数时应注意\n （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n---\n###### 参考文档[es6官方文档/函数的扩展](http://caibaojian.com/es6/function.html)\n###### 参考视频[bilibili.com/av47304735](https://search.bilibili.com/all?keyword=av47304735)\n","tags":["es6"]},{"title":"es6那些事(1)命令符","url":"/2019/09/22/es6那些事-1-命令符/","content":"# 关于var,let和const \n---\n## 变量var\n\n### 1.基本用法\n\n```\n var a=0;\n```\n\n---\n\n### 2.会进行覆盖\n```\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6]();\n```\n### 输出结果\n![输出结果](/img/变量覆盖.png)\n\n---\n\n### 3.存在变量提升\n```\nconsole.log(a);\na=5;\n```\n\n### 输出结果\n![](/img/变量提升.png)\n### 相当于\n```\nvar a;\nconsole.log(a);\na=5;\n```\n\n---\n\n### 4.可重复申明\n```\nvar a=3;\nvar a=5;\nconsole.log(a);\n```\n\n### 输出\n![](/img/重复申明.png)\n\n---\n\n## 块局变量let\n\n### 1.作用于局部\n```\n{let a=5;}\nconsole.log(a);\n```\n\n### 输出\n![](/img/局部变量.png)\n\n---\n\n### 2.不存在变量提升\n```\nconsole.log(a);\nlet a=2;\n```\n\n### var存在变量提升，所以输出undefined，let不存在变量提升，所以报错ReferenceError。\n![](/img/局部报错.png)\n\n---\n\n### 3.暂时性死区\n### 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n```\nvar a=123;\nif(true){\n     a='asd';\n     let a;\n   }\n```\n\n### 输出\n![](/img/封闭性区间.png)\n\n---\n\n## 另一个块局变量const\n\n### 1.申明只读常量\n### const申明的变量值不可再更改。\n```\nconst a=6;\na=5;\nconsole.log(a);\n```\n\n### 输出\n![](/img/只读常量.png)\n\n---\n\n### 2.const定义对象值不可更改，但属性可更改\n### 比如下面这种情况，const在定义时，其指针指向“person”,而不是里面的“name”和“age”，所以“age”和“name”可以改变。可以理解为人的外貌不变，但内心的想法可以改变。\n\n```\nconst person={\n            name:'小明',\n            age:20\n        }\nperson.age=30;\nconsole.log(person.age);\n```\n\n### 输出\n![](/img/const对象.png)\n\n---\n\n### 3.变量必须立刻初始化\n```\nconst a;\n```\n\n### 输出\n![](/img/const申明.png)\n\n---\n\n## 总结\n   ### 默认使用const,\n   ### 当变量需要更新时用let,\n   ### 尽量不使用var。\n\n---\n\n###### 参考文档[es6官方文档/let和const命令](http://caibaojian.com/es6/let.html)\n###### 参考视频[bilibili.com/av47304735](https://search.bilibili.com/all?keyword=av47304735)","tags":["es6"]},{"title":"Hello World","url":"/2019/08/31/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post1\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]